import pkcs11
from cryptography import x509
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey

from pkcs11 import lib, KeyType, Mechanism, ObjectClass, Attribute

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import (
    rsa,
    ec,
    padding as asym_padding,
)
from pkcs11.exceptions import NoSuchKey, PKCS11Error

from cryptography.hazmat.primitives.asymmetric.utils import Prehashed
from cryptography.hazmat.backends import default_backend
from cryptography.x509.oid import NameOID
import datetime

from typing import Union, Optional, Any
from abc import ABC, abstractmethod


class Pkcs11Utilities:
    """
    Utility class for general PKCS#11 operations not specific to private keys.
    Provides functions for slot/token management, random generation, object destruction, and mechanism listing.
    """

    def __init__(self, lib_path: str):
        """
        Initialize the PKCS#11 utility with the specified library path.

        Args:
            lib_path (str): Path to the PKCS#11 library.
        """
        self._lib = lib(lib_path)
        self._slots_cache = None
        self._tokens_cache = None

    def get_slots(self) -> list[pkcs11.Slot]:
        """
        Get all available slots in the PKCS#11 library with caching.

        Returns:
            List[pkcs11.Slot]: List of available slots.
        """
        if self._slots_cache is None:
            self._slots_cache = self._lib.get_slots()
        return self._slots_cache

    def get_tokens(self) -> list[pkcs11.Token]:
        """
        Get all available tokens in the PKCS#11 library with caching.

        Returns:
            List[pkcs11.Token]: List of available tokens.
        """
        if self._tokens_cache is None:
            self._tokens_cache = [slot.token for slot in self.get_slots()]
        return self._tokens_cache

    def get_token_by_label(self, token_label: str) -> pkcs11.Token:
        """
        Get a token by its label with optimized lookup.

        Args:
            token_label (str): Label of the token to find.

        Returns:
            pkcs11.Token: The found token.

        Raises:
            ValueError: If no token with the specified label is found.
        """
        for token in self.get_tokens():
            if token.label == token_label:
                return token
        raise ValueError(f"Token with label '{token_label}' not found.")

    def get_mechanisms(self, token_label: str) -> list[Mechanism]:
        """
        Get all mechanisms supported by the specified token.

        Args:
            token_label (str): Label of the token to check.

        Returns:
            List[Mechanism]: List of supported mechanisms.
        """
        token = self.get_token_by_label(token_label)
        return token.get_mechanisms()

    def open_session(self, token_label: str, user_pin: str) -> pkcs11.Session:
        """
        Open a session with the specified token.

        Args:
            token_label (str): Label of the token to open a session with.
            user_pin (str): User PIN for authentication.

        Returns:
            pkcs11.Session: The opened session.
        """
        token = self.get_token_by_label(token_label)
        return token.open(user_pin, rw=True)

    def generate_random(self, token_label: str, user_pin: str, length: int) -> bytes:
        """
        Generate cryptographically secure random bytes using the HSM.

        Args:
            token_label (str): Label of the token to use.
            user_pin (str): User PIN for the session.
            length (int): Number of random bytes to generate.

        Returns:
            bytes: Randomly generated bytes.
        """
        with self.open_session(token_label, user_pin) as session:
            return session.generate_random(length)

    def seed_random(self, token_label: str, user_pin: str, seed_data: bytes) -> None:
        """
        Seed the HSM's random number generator with provided entropy.

        Args:
            token_label (str): Label of the token to use.
            user_pin (str): User PIN for the session.
            seed_data (bytes): Entropy data to seed the RNG.
        """
        with self.open_session(token_label, user_pin) as session:
            session.seed_random(seed_data)

    def destroy_object(self, token_label: str, user_pin: str, label: str, key_type: KeyType,
                       object_class: ObjectClass) -> None:
        """
        Destroy a cryptographic object on the token.

        Args:
            token_label (str): Label of the token containing the object.
            user_pin (str): User PIN for the session.
            label (str): Label of the object to destroy.
            key_type (KeyType): Type of the key (RSA, EC, etc.).
            object_class (ObjectClass): Class of the object (PRIVATE_KEY, PUBLIC_KEY, etc.).

        Raises:
            ValueError: If the object doesn't exist.
        """
        with self.open_session(token_label, user_pin) as session:
            try:
                obj = session.get_key(label=label, key_type=key_type, object_class=object_class)
                obj.destroy()
            except NoSuchKey:
                raise ValueError(f"Object {object_class} with label '{label}' not found on token '{token_label}'.")


class Pkcs11PrivateKey(ABC):
    """
    Base class for PKCS#11-backed private keys (RSA, EC).
    """

    DIGEST_MECHANISMS = {
        hashes.SHA256: Mechanism.SHA256,
        hashes.SHA384: Mechanism.SHA384,
        hashes.SHA512: Mechanism.SHA512,
        hashes.SHA224: Mechanism.SHA224,
    }


    def __init__(self, lib_path: str, token_label: str, user_pin: str, key_label: str):
        self._lib = lib(lib_path)
        self._token = self._lib.get_token(token_label=token_label)
        self._session = self._token.open(user_pin=user_pin, rw=True)
        self._key_label = key_label
        self._key = None

    def copy_key(
        self,
        source_label: str,
        target_label: str,
        key_type: KeyType,
        object_class: ObjectClass,
        template: Optional[dict[Attribute, Any]] = None
    ) -> None:
        """
        Copy a cryptographic key with a new label and attributes.

        Args:
            source_label (str): Label of the source key.
            target_label (str): Label for the copied key.
            key_type (KeyType): Type of the key (RSA, EC, etc.).
            object_class (ObjectClass): Class of the object to copy.
            template (Optional[Dict[Attribute, Any]]): Optional template for new attributes.

        Raises:
            ValueError: If source key doesn't exist.
        """
        source_key = self._session.get_key(label=source_label, key_type=key_type, object_class=object_class)
        template = template or {}
        template[Attribute.LABEL] = target_label
        source_key.copy(template=template)

    def destroy_object(self, label: str, key_type: KeyType, object_class: ObjectClass) -> None:
        """
        Destroy a cryptographic object on the token.

        Args:
            label (str): Label of the object to destroy.
            key_type (KeyType): Type of the key (RSA, EC, etc.).
            object_class (ObjectClass): Class of the object (PRIVATE_KEY, PUBLIC_KEY, etc.).

        Raises:
            ValueError: If the object doesn't exist.
        """
        try:
            obj = self._session.get_key(label=label, key_type=key_type, object_class=object_class)
            obj.destroy()
        except NoSuchKey:
            raise ValueError(f"Object {object_class} with label '{label}' not found.")

    def digest_data(self, data: bytes, algorithm: hashes.HashAlgorithm) -> bytes:
        """
        Perform a cryptographic digest operation on the provided data using the HSM.

        Args:
            data (bytes): Data to be hashed.
            algorithm (hashes.HashAlgorithm): Hash algorithm to use.

        Returns:
            bytes: The resulting hash.

        Raises:
            ValueError: If the algorithm is not supported.
        """
        mechanism = self.DIGEST_MECHANISMS.get(type(algorithm))
        if mechanism is None:
            raise ValueError(f"Unsupported digest algorithm: {algorithm.name}")

        return self._session.digest(mechanism, data)

    def _key_exists(self, key_type: KeyType, object_class: ObjectClass) -> bool:
        """
        Check if a key with the specified type and object class exists on the token.

        Args:
            key_type (KeyType): The key type (e.g., RSA, EC).
            object_class (ObjectClass): The object class (PRIVATE_KEY or PUBLIC_KEY).

        Returns:
            bool: True if the key exists, False otherwise.
        """
        try:
            self._session.get_key(
                label=self._key_label,
                key_type=key_type,
                object_class=object_class
            )
            return True
        except NoSuchKey:
            return False


    @abstractmethod
    def sign(self, data: bytes, padding: Optional[asym_padding.AsymmetricPadding], algorithm: hashes.HashAlgorithm) -> bytes:
        """
        Sign the provided data using the private key.

        Args:
            data (bytes): Data to be signed.
            padding (Optional[asym_padding.AsymmetricPadding]): Padding scheme to use (if applicable).
            algorithm (hashes.HashAlgorithm): Hash algorithm to use for signing.

        Returns:
            bytes: The signature.

        Raises:
            NotImplementedError: If the padding or algorithm is not supported.
        """
        ...

    @abstractmethod
    def public_key(self) -> Union[RSAPublicKey, ec.EllipticCurvePublicKey]:
        """
        Return the public key associated with this private key.

        Returns:
            Union[RSAPublicKey, ec.EllipticCurvePublicKey]: The public key object.
        """
        ...

    @abstractmethod
    def key_size(self) -> int:
        """
        Return the key size in bits.

        Returns:
            int: The key size.
        """
        ...

    def destroy_key(self) -> None:
        """
        Destroy the current private key and associated public key.

        Raises:
            ValueError: If the key doesn't exist.
        """
        if self._key is None:
            raise ValueError("Current key does not exist.")

        try:
            self._key.destroy()
            self._key = None
            if hasattr(self, '_public_key'):
                self._public_key = None
        except PKCS11Error as e:
            raise RuntimeError(f"Failed to destroy key: {e}")

    def close(self) -> None:
        """
        Close the session with the token.
        """
        if hasattr(self, '_session') and self._session:
            self._session.close()


    def __enter__(self) -> 'Pkcs11PrivateKey':
        """
        Context manager entry point.

        Returns:
            Pkcs11PrivateKey: The current instance.
        """
        return self

    def __exit__(self, exc_type: Optional[type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[Any]) -> None:
        """
        Context manager exit point, closes the session.

        Args:
            exc_type (Optional[Type[BaseException]]): Exception type if an error occurred.
            exc_value (Optional[BaseException]]): Exception instance if an error occurred.
            traceback (Optional[Any]]): Traceback if an error occurred.
        """
        self.close()


class Pkcs11RSAPrivateKey(Pkcs11PrivateKey, rsa.RSAPrivateKey):

    DEFAULT_PUBLIC_TEMPLATE = {
        Attribute.ENCRYPT: True,
        Attribute.VERIFY: True,
        Attribute.MODIFIABLE: True,
        Attribute.TOKEN: True,
        Attribute.PUBLIC_EXPONENT: (0x01, 0x00, 0x01),  # 65537
    }

    DEFAULT_PRIVATE_TEMPLATE = {
        Attribute.DECRYPT: True,
        Attribute.SIGN: True,
        Attribute.SENSITIVE: True,
        Attribute.EXTRACTABLE: False,
        Attribute.MODIFIABLE: True,
        Attribute.TOKEN: True,
    }

    def __init__(self, lib_path: str, token_label: str, user_pin: str, key_label: str):
        """
        Initialize an RSA private key handler for PKCS#11 tokens.

        Args:
            lib_path (str): Path to the PKCS#11 library.
            token_label (str): Label of the HSM token.
            user_pin (str): User PIN for the token.
            key_label (str): Label of the RSA private key.
        """
        super().__init__(lib_path, token_label, user_pin, key_label)
        self._public_key = None

    def load_key(self) -> None:
        """
        Load RSA private key from token using the specified label.

        Raises:
            ValueError: If the RSA private key is not found.
        """
        if self._key is not None:
            return

        try:
            self._key = self._session.get_key(
                label=self._key_label,
                key_type=KeyType.RSA,
                object_class=ObjectClass.PRIVATE_KEY
            )
        except NoSuchKey:
            raise ValueError(f"RSA private key with label '{self._key_label}' not found on token '{self._token.label}'.")

    def generate_key(
            self,
            key_length: int = 2048,
            public_template: Optional[dict[Attribute, Any]] = None,
            private_template: Optional[dict[Attribute, Any]] = None,
    ) -> None:
        """
        Generate RSA key pair and store handles on the token.

        Args:
            key_length (int): Length of the RSA key in bits (default 2048).
            public_template (Optional[Dict[Attribute, Any]]): Template for public key attributes.
            private_template (Optional[Dict[Attribute, Any]]): Template for private key attributes.

        Raises:
            ValueError: If a key with the same label already exists.
        """
        if self._key_exists(KeyType.RSA, ObjectClass.PRIVATE_KEY):
            raise ValueError(f"RSA key with label '{self._key_label}' already exists on token '{self._token.label}'.")

        final_public_template = self.DEFAULT_PUBLIC_TEMPLATE.copy()
        final_public_template[Attribute.LABEL] = self._key_label
        if public_template:
            final_public_template.update(public_template)

        final_private_template = self.DEFAULT_PRIVATE_TEMPLATE.copy()
        final_private_template[Attribute.LABEL] = self._key_label
        if private_template:
            final_private_template.update(private_template)

        pub, priv = self._session.generate_keypair(
            KeyType.RSA,
            key_length,
            public_template=final_public_template,
            private_template=final_private_template,
            store=True
        )

        self._key = priv
        self._public_key = None

    def sign(self, data: bytes, padding: asym_padding.AsymmetricPadding, algorithm: hashes.HashAlgorithm) -> bytes:
        """
        Sign the provided data using the RSA private key with PKCS#1 v1.5 padding.

        Args:
            data (bytes): Data to be signed.
            padding (asym_padding.AsymmetricPadding): Padding scheme to use (must be PKCS1v15).
            algorithm (hashes.HashAlgorithm): Hash algorithm to use for signing.

        Returns:
            bytes: The RSA signature.

        Raises:
            NotImplementedError: If padding is not PKCS1v15.
            ValueError: If Prehashed digest is used.
        """
        if self._key is None:
            self.load_key()

        if not isinstance(padding, asym_padding.PKCS1v15):
            raise NotImplementedError("Only PKCS#1 v1.5 supported.")

        if isinstance(algorithm, Prehashed):
            raise ValueError("Prehashed digests not supported.")

        digest = hashes.Hash(algorithm)
        digest.update(data)
        digest_bytes = digest.finalize()

        return self._key.sign(digest_bytes, mechanism=Mechanism.RSA_PKCS)

    def public_key(self) -> RSAPublicKey:
        """
        Return the cached or retrieved RSA public key.

        Returns:
            RSAPublicKey: The RSA public key.

        Raises:
            ValueError: If the public key is not found or invalid.
        """
        if self._public_key:
            return self._public_key

        try:
            public = self._session.get_key(
                label=self._key_label,
                key_type=KeyType.RSA,
                object_class=ObjectClass.PUBLIC_KEY
            )
        except NoSuchKey:
            raise ValueError(f"RSA public key with label '{self._key_label}' not found on token '{self._token.label}'.")

        n = public[Attribute.MODULUS]
        e = public[Attribute.PUBLIC_EXPONENT]
        n = int.from_bytes(n, "big") if isinstance(n, bytes) else n
        e = int.from_bytes(e, "big") if isinstance(e, bytes) else e

        self._public_key = rsa.RSAPublicNumbers(e, n).public_key()
        return self._public_key

    def key_size(self) -> int:
        """
        Return the RSA key size in bits.

        Returns:
            int: The key size.
        """
        if self._key is None:
            self.load_key()
        return self._key.key_length

    def encrypt(self, plaintext: bytes) -> bytes:
        """
        Encrypt the given plaintext using the RSA public key with PKCS#1 v1.5 padding.

        Args:
            plaintext (bytes): Data to be encrypted.

        Returns:
            bytes: The encrypted ciphertext.

        Raises:
            NoSuchKey: If the public key is not found.
        """
        try:
            public_key = self._session.get_key(
                label=self._key_label,
                key_type=KeyType.RSA,
                object_class=ObjectClass.PUBLIC_KEY
            )
            return public_key.encrypt(plaintext, mechanism=Mechanism.RSA_PKCS)
        except NoSuchKey:
            raise ValueError(f"RSA public key with label '{self._key_label}' not found.")

    def decrypt(self, ciphertext: bytes, padding: asym_padding.AsymmetricPadding) -> bytes:
        """
        Decrypt the given ciphertext using the RSA private key.

        Args:
            ciphertext (bytes): Data to be decrypted.
            padding (asym_padding.AsymmetricPadding): Padding scheme to use (PKCS1v15 or OAEP).

        Returns:
            bytes: The decrypted plaintext.

        Raises:
            NotImplementedError: If the padding is not supported.
        """
        if self._key is None:
            self.load_key()

        if isinstance(padding, asym_padding.PKCS1v15):
            mechanism = Mechanism.RSA_PKCS
        elif isinstance(padding, asym_padding.OAEP):
            mechanism = Mechanism.RSA_PKCS_OAEP
        else:
            raise NotImplementedError(f"Unsupported padding: {type(padding)}")

        return self._key.decrypt(ciphertext, mechanism=mechanism)

    def private_numbers(self) -> None:
        """
        Not implemented for PKCS#11 private keys.

        Raises:
            NotImplementedError: Always.
        """
        raise NotImplementedError("Private numbers are not accessible.")

    def private_bytes(self, *args, **kwargs) -> None:
        """
        Not implemented for PKCS#11 private keys.

        Raises:
            NotImplementedError: Always.
        """
        raise NotImplementedError("Export of private key bytes is not supported.")

    def __copy__(self) -> 'Pkcs11RSAPrivateKey':
        """
        Return the same instance since copying is not supported for PKCS#11 keys.

        Returns:
            Pkcs11RSAPrivateKey: The current instance.
        """
        return self


class Pkcs11ECPrivateKey(Pkcs11PrivateKey, ec.EllipticCurvePrivateKey):

    CURVE_KEY_LENGTHS = {
        ec.SECP256R1: 256,
        ec.SECP384R1: 384,
        ec.SECP521R1: 521,
    }

    EC_MECHANISMS = {
        hashes.SHA256: Mechanism.ECDSA_SHA256,
        hashes.SHA384: Mechanism.ECDSA_SHA384,
        hashes.SHA512: Mechanism.ECDSA_SHA512,
    }

    DEFAULT_PUBLIC_TEMPLATE = {
        Attribute.VERIFY: True,
        Attribute.MODIFIABLE: True,
        Attribute.TOKEN: True,
    }

    DEFAULT_PRIVATE_TEMPLATE = {
        Attribute.SIGN: True,
        Attribute.SENSITIVE: True,
        Attribute.EXTRACTABLE: False,
        Attribute.MODIFIABLE: True,
        Attribute.TOKEN: True,
    }

    def __init__(self, lib_path: str, token_label: str, user_pin: str, key_label: str):
        """
        Initialize an EC private key handler for PKCS#11 tokens.

        Args:
            lib_path (str): Path to the PKCS#11 library.
            token_label (str): Label of the HSM token.
            user_pin (str): User PIN for the token.
            key_label (str): Label of the EC private key.
        """
        super().__init__(lib_path, token_label, user_pin, key_label)
        self._public_key = None

    def load_key(self) -> None:
        """
        Load EC private key from token using the specified label.

        Raises:
            ValueError: If the EC private key is not found.
        """
        if self._key is not None:
            return

        try:
            self._key = self._session.get_key(
                label=self._key_label,
                key_type=KeyType.EC,
                object_class=ObjectClass.PRIVATE_KEY
            )
        except NoSuchKey:
            raise ValueError(f"EC private key with label '{self._key_label}' not found on token '{self._token.label}'.")

    def generate_key(
            self,
            curve: ec.EllipticCurve = ec.SECP256R1(),
            public_template: Optional[dict[Attribute, Any]] = None,
            private_template: Optional[dict[Attribute, Any]] = None,
    ) -> None:
        """
        Generate EC key pair and store it on the token.

        Args:
            curve (ec.EllipticCurve): The elliptic curve to use (default SECP256R1).
            public_template (Optional[Dict[Attribute, Any]]): Template for public key attributes.
            private_template (Optional[Dict[Attribute, Any]]): Template for private key attributes.

        Raises:
            ValueError: If a key with the same label already exists or unsupported curve.
        """
        if self._key_exists(KeyType.EC, ObjectClass.PRIVATE_KEY):
            raise ValueError(f"EC key with label '{self._key_label}' already exists on token '{self._token.label}'.")

        key_length = self.CURVE_KEY_LENGTHS.get(type(curve))
        if key_length is None:
            raise ValueError(f"Unsupported curve: {curve.name}")

        # Create templates with label
        final_public_template = self.DEFAULT_PUBLIC_TEMPLATE.copy()
        final_public_template[Attribute.LABEL] = self._key_label
        if public_template:
            final_public_template.update(public_template)

        final_private_template = self.DEFAULT_PRIVATE_TEMPLATE.copy()
        final_private_template[Attribute.LABEL] = self._key_label
        if private_template:
            final_private_template.update(private_template)

        pub, priv = self._session.generate_keypair(
            KeyType.EC,
            key_length,
            public_template=final_public_template,
            private_template=final_private_template,
            store=True,
        )

        self._key = priv
        self._public_key = None

    def sign(self, data: bytes, padding: Optional[asym_padding.AsymmetricPadding],
             algorithm: hashes.HashAlgorithm) -> bytes:
        """
        Sign the provided data using the EC private key with ECDSA.

        Args:
            data (bytes): Data to be signed.
            padding (Optional[asym_padding.AsymmetricPadding]): Must be None for EC keys.
            algorithm (hashes.HashAlgorithm): The hash algorithm to use for signing.

        Returns:
            bytes: The ECDSA signature.

        Raises:
            ValueError: If padding is not None or unsupported hash algorithm.
        """
        if self._key is None:
            self.load_key()

        if not isinstance(algorithm, ec.ECDSA):
            raise NotImplementedError("Only ECDSA is supported.")

        if isinstance(algorithm.algorithm, Prehashed):
            raise ValueError("Prehashed not supported.")

        digest = hashes.Hash(algorithm.algorithm)
        digest.update(data)
        hashed = digest.finalize()

        mechanism = self.EC_MECHANISMS.get(type(algorithm.algorithm))
        if mechanism is None:
            raise ValueError(f"Unsupported EC algorithm: {type(algorithm.algorithm)}")

        return self._key.sign(hashed, mechanism=mechanism)

    def public_key(self) -> ec.EllipticCurvePublicKey:
        """
        Return the cached or retrieved EC public key.

        Returns:
            ec.EllipticCurvePublicKey: The EC public key.

        Raises:
            ValueError: If the public key is not found or invalid.
        """
        if self._public_key:
            return self._public_key

        try:
            public = self._session.get_key(
                label=self._key_label,
                key_type=KeyType.EC,
                object_class=ObjectClass.PUBLIC_KEY
            )
        except NoSuchKey:
            raise ValueError(f"EC public key with label '{self._key_label}' not found on token '{self._token.label}'.")

        try:
            x, y = public.public_key
        except AttributeError:
            raise ValueError("EC public key point is missing or invalid.")

        curve = self.curve()
        pub_numbers = ec.EllipticCurvePublicNumbers(x, y, curve)
        self._public_key = pub_numbers.public_key()
        return self._public_key

    def key_size(self) -> int:
        """
        Return the EC key size in bits.

        Returns:
            int: The key size.
        """
        if self._key is None:
            self.load_key()
        return self._key.key_length

    def encrypt(self, plaintext: bytes) -> None:
        """
        Not implemented for EC keys.

        Raises:
            NotImplementedError: Always.
        """
        raise NotImplementedError("EC encryption is not supported by PKCS#11.")

    def decrypt(self, ciphertext: bytes, padding: asym_padding.AsymmetricPadding) -> None:
        """
        Not implemented for EC keys.

        Raises:
            NotImplementedError: Always.
        """
        raise NotImplementedError("EC decryption is not supported by PKCS#11.")

    def private_numbers(self) -> None:
        """
        Not implemented for PKCS#11 private keys.

        Raises:
            NotImplementedError: Always.
        """
        raise NotImplementedError("Private numbers not accessible.")

    def private_bytes(self, *args, **kwargs) -> None:
        """
        Not implemented for PKCS#11 private keys.

        Raises:
            NotImplementedError: Always.
        """
        raise NotImplementedError("Export of private key is not supported.")

    def exchange(self, algorithm: Any, peer_public_key: Any) -> None:
        """
        Not implemented for EC keys.

        Raises:
            NotImplementedError: Always.
        """
        raise NotImplementedError("Key exchange not implemented.")

    def curve(self) -> ec.EllipticCurve:
        """
        Return the elliptic curve used by the private key.

        Returns:
            ec.EllipticCurve: The curve object.

        Raises:
            ValueError: If the key size is not supported.
        """
        if self._key is None:
            self.load_key()
        key_size = self._key.key_length

        for curve_class, length in self.CURVE_KEY_LENGTHS.items():
            if length == key_size:
                return curve_class()

        raise ValueError(f"Unsupported EC key size: {key_size}")

    def __copy__(self) -> 'Pkcs11ECPrivateKey':
        """
        Return the same instance since copying is not supported for PKCS#11 keys.

        Returns:
            Pkcs11ECPrivateKey: The current instance.
        """
        return self


if __name__== '__main__':

    key = Pkcs11RSAPrivateKey(
        lib_path="/usr/lib/softhsm/libsofthsm2.so",
        token_label="MyToken",
        user_pin="1234",
        key_label="issuer-key-10"
    )

    key.generate_key(2048)

    message = b"Hello from SoftHSM + PKCS#11 RSA!"

    signature = key.sign(
        message,
        padding=padding.PKCS1v15(),
        algorithm=hashes.SHA256()
    )

    print(f"Signature: {signature}")

    ciphertext = key.encrypt(b"Hello world!")

    plaintext = key.decrypt(ciphertext, padding=padding.PKCS1v15())

    assert plaintext == b"Hello world!"

    subject = issuer = x509.Name([
        x509.NameAttribute(NameOID.COUNTRY_NAME, "DE"),
        x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "BW"),
        x509.NameAttribute(NameOID.LOCALITY_NAME, "FDS"),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Trustpoint"),
        x509.NameAttribute(NameOID.COMMON_NAME, "HSM"),
    ])

    not_valid_before = datetime.datetime.utcnow()
    not_valid_after = not_valid_before + datetime.timedelta(days=365)

    builder = (
        x509.CertificateBuilder()
        .subject_name(subject)
        .issuer_name(issuer)
        .public_key(key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(not_valid_before)
        .not_valid_after(not_valid_after)
        .add_extension(
            x509.BasicConstraints(ca=True, path_length=None), critical=True
        )
    )

    certificate = builder.sign(
        private_key=key,
        algorithm=hashes.SHA256()
    )

    print(certificate.public_bytes(serialization.Encoding.PEM).decode())
